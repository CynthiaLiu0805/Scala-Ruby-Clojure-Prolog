<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-11-26 Thu 21:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Science 3MI3 – 2020 Assignment 2: Typing a λ-calculus</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Cynthia Liu" />
<meta name="description" content="Assignment 2 in Scala and Ruby implementation"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Computer Science 3MI3 – 2020 Assignment 2: Typing a λ-calculus</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">1. Introduction</a></li>
<li><a href="#Part one: The representation">2. Part one: The representation</a>
<ul>
<li><a href="#Representation in Scala">2.1. Representation in Scala</a></li>
<li><a href="#Representation in Ruby">2.2. Representation in Ruby</a></li>
</ul>
</li>
<li><a href="#Part two: Typechecking">3. Part two: Typechecking</a>
<ul>
<li><a href="#Scala implementation">3.1. Scala implementation</a>
<ul>
<li><a href="#typeOf">3.1.1. typeOf</a></li>
<li><a href="#typecheck">3.1.2. typecheck</a></li>
</ul>
</li>
<li><a href="#Ruby implementation">3.2. Ruby implementation</a>
<ul>
<li><a href="#typeOf">3.2.1. typeOf</a></li>
<li><a href="#typecheck">3.2.2. typecheck</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Part three: Translation to the untyped λ-calculus">4. Part three: Translation to the untyped λ-calculus</a>
<ul>
<li><a href="#Scala implementation">4.1. Scala implementation</a></li>
<li><a href="#Ruby implementation">4.2. Ruby implementation</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga116e60" class="outline-2">
<h2 id="Introduction"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
This is the documentation for Assignment 2 for COMPSCI3MI3 2020fall. 
</p>

<p>
It is about constructing representation of a simply-typed λ-calculus, 
and a typechecker for that λ-calculus, as well as a type-erasure and a simple translator to simplify terms to untyped λ-calculus terms.
</p>

<p>
This Assignment is written in both Scala and Ruby. 
</p>
</div>
</div>

<div id="outline-container-org2746fef" class="outline-2">
<h2 id="Part one: The representation"><span class="section-number-2">2</span> Part one: The representation</h2>
<div class="outline-text-2" id="text-Part one: The representation">
</div>

<div id="outline-container-org0afaf32" class="outline-3">
<h3 id="Representation in Scala"><span class="section-number-3">2.1</span> Representation in Scala</h3>
<div class="outline-text-3" id="text-Representation in Scala">
<p>
The terms of the λ-calculus ST are expressed in the new type <code>STTerm</code>.
</p>
<ul class="org-ul">
<li>The constructor <code>STVar</code> take a parameter of type <code>Int</code>.</li>
<li>The constructor <code>STZero</code>, <code>STTrue</code>, <code>STFalse</code> take no arguments, so they are implemented as case object</li>
<li>The constructor <code>STSuc</code>, <code>STIsZero</code> take one parameters of type <code>STTerm</code>.</li>
<li>The constructor <code>STApp</code> takes two parameters of type <code>STTerm</code>.</li>
<li>The constructor <code>STAbs</code> takes two parameters, one is of type <code>STTerm</code>, the other is of type <code>STType</code>.</li>
<li>The constructor <code>STTest</code> takes three parameters of type <code>STTerm</code>.</li>
</ul>


<div class="org-src-container">
<pre class="src src-amm">sealed trait STTerm
case class STVar(index: Int) extends STTerm
case class STApp(t1: STTerm,t2: STTerm) extends STTerm
case class STAbs(t: STType,term: STTerm) extends STTerm

case object STZero extends STTerm
case class STSuc(t: STTerm) extends STTerm
case class STIsZero(t: STTerm) extends STTerm

case object STTrue extends STTerm
case object STFalse extends STTerm
case class STTest(t1: STTerm,t2: STTerm,t3: STTerm) extends STTerm

</pre>
</div>
</div>
</div>


<div id="outline-container-org5010ee1" class="outline-3">
<h3 id="Representation in Ruby"><span class="section-number-3">2.2</span> Representation in Ruby</h3>
<div class="outline-text-3" id="text-Representation in Ruby">
<p>
In Ruby, all constructors are subtypes of type <code>STTerm</code>, that is, they all inherites from <code>STTerm</code>
</p>
<div class="org-src-container">
<pre class="src src-Ruby">class STTerm end
</pre>
</div>

<p>
The operator <code>&lt;</code> means inheritance, for each class, we have an initialize method to initialize the object, and we have a == method to do comparsion.
</p>
<ul class="org-ul">
<li>For <code>STVar</code>, it is initialized with an integer.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STVar &lt; STTerm
  attr_reader :index
  # We require our variables are only indexed by integers.
  def initialize(index)
    unless index.is_a?(Integer) 
      throw "Constructing a STVar out of non-integer terms"
    end
    @index = index
  end
  def ==(type); type.is_a?(STVat) &amp;&amp; type.index==@index end
end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STZero</code>, <code>STTrue</code>, <code>STFalse</code>, they are initialized directly.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STZero &lt; STTerm
  def ==(type); type.is_a?(STZero) end
  def to_s; "zero" end
  def typeOf(arr); STNat.new end
end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STSuc</code>, <code>STIsZero</code>, they are initialized with a <code>STTerm</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STSuc &lt; STTerm
    attr_reader :t
    def initialize(t)
      unless t.is_a?(STTerm)
	throw "Constructing a lambda term out of non-lambda terms"
      end
      @t = t
    end

    def ==(type); type.is_a?(STSuc) &amp;&amp; type.t==@t end
end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STApp</code>, it is initialized with two <code>STTerm</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STApp &lt; STTerm
    attr_reader :t1
    attr_reader :t2
    def initialize(t1,t2)
      unless t1.is_a?(STTerm) &amp;&amp; t2.is_a?(STTerm)
	throw "Constructing a lambda term out of non-lambda terms"
      end
      @t1 = t1; @t2 = t2
    end
    def ==(type); type.is_a?(STApp) &amp;&amp; type.t1==@t1 &amp;&amp; type.t2==@t2 end
  end  
</pre>
</div>

<ul class="org-ul">
<li>For <code>STAbs</code>, it is initialized with a <code>STTerm</code> and a <code>STType</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STAbs &lt; STTerm
    attr_reader :t1
    attr_reader :t2
    def initialize(t1,t2)
      unless t1.is_a?(STType) &amp;&amp; t2.is_a?(STTerm)
	throw "Constructing a lambda term out of non-lambda terms"
      end
      @t1 = t1; @t2 = t2
    end

    def ==(type); type.is_a?(STAbs) &amp;&amp; type.t1==@t1 &amp;&amp; type.t2==@t2 end
end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STTest</code>, it is initialized with three <code>STTerm</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Ruby">class STTest &lt; STTerm
   attr_reader :t1
   attr_reader :t2
   attr_reader :t3

   # We require our variables are only indexed by integers.
   def initialize(t1,t2,t3)
     unless t1.is_a?(STTerm) &amp;&amp; t2.is_a?(STTerm) &amp;&amp; t2.is_a?(STTerm)
       throw "Constructing a lambda term out of non-lambda terms"
     end
     @t1 = t1; @t2 = t2; @t3=t3
   end

   def ==(type); type.is_a?(STTest) &amp;&amp; type.t1==@t1 &amp;&amp; type.t2==@t2 &amp;&amp; type.t3==@t3 end
 end
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgab97f3a" class="outline-2">
<h2 id="Part two: Typechecking"><span class="section-number-2">3</span> Part two: Typechecking</h2>
<div class="outline-text-2" id="text-Part two: Typechecking">
<p>
This method takes a <code>STTerm</code>, and returns true if the represented term obeys the type rules of ST; 
otherwise, it returns false.
</p>
</div>

<div id="outline-container-org6442c38" class="outline-3">
<h3 id="Scala implementation"><span class="section-number-3">3.1</span> Scala implementation</h3>
<div class="outline-text-3" id="text-Scala implementation">
</div>

<div id="outline-container-org085ab74" class="outline-4">
<h4 id="typeOf"><span class="section-number-4">3.1.1</span> typeOf</h4>
<div class="outline-text-4" id="text-typeOf">
<p>
This method determine a type for the input <code>STTerm</code>. 
It has two arguments, one is the <code>STTerm</code>, the other one is an typing context, here an empty list is used.
It return a <code>Option[STType]</code>.
</p>

<ul class="org-ul">
<li>Acccording to the typing rule, for <code>STVar</code>, the type is given by the environment</li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STVar(index) =&gt; None                                                                                                                                                                                                                                             
</pre>
</div>

<ul class="org-ul">
<li>For <code>STTrue</code>, <code>STFalse</code>, the type is <code>STBool</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STTrue | STFalse =&gt; Some(STBool)
</pre>
</div>

<ul class="org-ul">
<li>For <code>STIsZero</code>, if the type of its parameter t is <code>STNat</code>, then the type of <code>STBool</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STIsZero(t) =&gt; if (typeOf(t,List[STType]())==Some(STNat)) Some(STBool) else None
</pre>
</div>

<ul class="org-ul">
<li>For <code>STZero</code>, the type is <code>STNat</code></li>
<li>For <code>STSuc</code>, if the type of its parameter t is <code>STNat</code>, then the type is <code>STNat</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STZero =&gt; Some(STNat)
case STSuc(t) =&gt; if (typeOf(t,List[STType]())==Some(STNat)) Some(STNat) else None
</pre>
</div>

<ul class="org-ul">
<li><p>
For <code>STAbs</code>, we add the type to the list(environment) first, if the index(index parameter of the <code>STVar</code>) at the list is of type t, return A -&gt; B.
</p>

<p>
If it is a free variable, return None. If it is not a <code>STVar</code>, use recursion to find the type of the term
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STAbs(t,term) =&gt; 
  term match {    
    case STVar(index) if ((l:+(t)).length &lt; index) =&gt; None
    case STVar(index) if (((l:+(t)).lift(index).get)==t) =&gt; Some(STFun(t,STNat))
    case STApp(t1, t2) =&gt; ((l:+(t)).lift(0).get) match {case STFun(dom,codom) if (dom==t) =&gt; Some(STNat)
    case _ =&gt; Some(STFun(t,typeOf(term,l:+(t)).get))
  }
</pre>
</div>

<ul class="org-ul">
<li><p>
For <code>STApp</code>, we add the type of t1 to the list and get the first element of the list.
</p>

<p>
If it is of type A -&gt; B, check if type1 is the same as type of t2, if so, the general type is type2, if not, return None.
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STApp(t1, t2) =&gt; (typeOf(t1,List[STType]())::l)(0) match {
    case Some(STFun(type1,type2)) if Some(type1)==typeOf(t2,List[STType]()) =&gt; Some(type2)
    case _ =&gt; None 
  } 
</pre>
</div>
</div>
</div>


<div id="outline-container-orga8b6659" class="outline-4">
<h4 id="typecheck"><span class="section-number-4">3.1.2</span> typecheck</h4>
<div class="outline-text-4" id="text-typecheck">
<p>
This method takes an <code>STTerm</code>, and returns <code>true</code> if the represented term obeys the type rules of ST; 
otherwise, it returns false.
</p>

<p>
The <code>typeOf</code> method is called in this method, if it return some type, the result is true, else it is false. 
Also, if exception occurs, it is false
</p>
<div class="org-src-container">
<pre class="src src-scala">def typecheck(input:STTerm):Boolean= try {
  if (typeOf(input, List[STType]())==None) {
    return false
  }
  else {
    return true
  }
}
  catch {
      case _: Throwable =&gt; false
  }
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org5453523" class="outline-3">
<h3 id="Ruby implementation"><span class="section-number-3">3.2</span> Ruby implementation</h3>
<div class="outline-text-3" id="text-Ruby implementation">
</div>

<div id="outline-container-org46a422b" class="outline-4">
<h4 id="typeOf"><span class="section-number-4">3.2.1</span> typeOf</h4>
<div class="outline-text-4" id="text-typeOf">
<p>
This method determine a type for the input <code>STTerm</code>. 
As it is implemented in each class, an empty environment is passed as argument. Here, an empty array is used.
</p>

<ul class="org-ul">
<li>For <code>STVar</code>, the type is given by the environment</li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr); nil end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STTrue</code>, <code>STFalse</code>, the type is <code>STBool</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr); STBool.new end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STIsZero</code>, if the type of its parameter t is <code>STNat</code>, then the type of <code>STBool</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr)
      if t.typeOf(Array.new)==STNat.new
	return STBool.new
      else 
	return nil
      end  
    end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STZero</code>, the type is <code>STNat</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr); STNat.new end
</pre>
</div>

<ul class="org-ul">
<li><p>
For <code>STAbs</code>, if t2 is of type <code>STVar</code>, we add the type to the list(environment) first, and the index(index parameter of the <code>STVar</code>) at the list is of type t1, return A -&gt; B.
</p>

<p>
If it is a free variable, return None. If it is not a <code>STVar</code>, use recursion to find the type of the term
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr)
  case t2
  when STVar
    if (arr&lt;&lt;t1)[t2.index]==t1
      return STFun.new(t1,STNat.new)
    else 
      return nil
    end
  when STApp
    if (arr&lt;&lt;t1)[0].dom == t1
      return STNat.new
    end
  else 
    return STFun.new(t1,t2.typeOf(arr&lt;&lt;t1))
  end
end
</pre>
</div>

<ul class="org-ul">
<li><p>
For <code>STApp</code>, we check the type of t1, if it is <code>STFun</code>, we then check if its dom is the same as the type of t2.
</p>

<p>
If so, return its condom, else, return nil
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def typeOf(arr)
      case t1.typeOf(Array.new)
      when STFun
	if t1.typeOf(Array.new).dom == t2.typeOf(Array.new)
	  return t1.typeOf(Array.new).codom
	else
	  return nil
	end
      else 
	return nil
      end
    end
</pre>
</div>
</div>
</div>


<div id="outline-container-org06c8db6" class="outline-4">
<h4 id="typecheck"><span class="section-number-4">3.2.2</span> typecheck</h4>
<div class="outline-text-4" id="text-typecheck">
<p>
This method takes an <code>STTerm</code>, and returns <code>true</code> if the represented term obeys the type rules of ST; 
otherwise, it returns false.
</p>

<p>
The <code>typeOf</code> method is called in this method, if it return some type, the result is true, else it is false. 
Also, as this method applies to all class, it is defined in the super class STTerm
</p>
<div class="org-src-container">
<pre class="src src-ruby">class STTerm 
  def typecheck
    if typeOf(Array.new)==nil
      return false
    else
      return true
    end
  end
end
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org70cde45" class="outline-2">
<h2 id="Part three: Translation to the untyped λ-calculus"><span class="section-number-2">4</span> Part three: Translation to the untyped λ-calculus</h2>
<div class="outline-text-2" id="text-Part three: Translation to the untyped λ-calculus">
<p>
This method translates a STTerm into elements of ULTerm.
</p>
</div>

<div id="outline-container-orgeb53753" class="outline-3">
<h3 id="Scala implementation"><span class="section-number-3">4.1</span> Scala implementation</h3>
<div class="outline-text-3" id="text-Scala implementation">
<ul class="org-ul">
<li>For <code>STVar</code>, <code>STTrue</code>, <code>STFalse</code>, <code>STZero</code> they are translated directly</li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STVar(index) =&gt; ULVar(index)
case STTrue =&gt; ULAbs(ULAbs(ULVar(1)))
case STFalse =&gt; ULAbs(ULAbs(ULVar(0)))
case STZero =&gt; ULAbs(ULAbs(ULVar(0)))
</pre>
</div>

<ul class="org-ul">
<li>For <code>STSuc(t)</code>, the <code>Suc</code> part is default, and <code>ULApp</code> is used to combine it with t in untyped lambda form.</li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STSuc(t) =&gt; ULApp(ULAbs(ULAbs(ULAbs(ULApp(ULVar(1),ULApp(ULApp(ULVar(2),ULVar(1)),ULVar(0)))))),eraseTypes(t))
</pre>
</div>

<ul class="org-ul">
<li>For <code>STApp</code> and <code>STAbs</code>, they are translated using recursion</li>
</ul>
<div class="org-src-container">
<pre class="src src-scala">case STApp(t1, t2) =&gt; ULApp(eraseTypes(t1),eraseTypes(t2))
case STAbs(t, term) =&gt; ULAbs(eraseTypes(term))
</pre>
</div>
</div>
</div>


<div id="outline-container-org52b5885" class="outline-3">
<h3 id="Ruby implementation"><span class="section-number-3">4.2</span> Ruby implementation</h3>
<div class="outline-text-3" id="text-Ruby implementation">
<ul class="org-ul">
<li>For <code>STVar</code>, <code>STTrue</code>, <code>STFalse</code>, <code>STZero</code> they are translated directly</li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def eraseTypes; ULVar.new(index) end
def eraseTypes; ULAbs.new(ULAbs.new(ULVar.new(1))) end
def eraseTypes; ULAbs.new(ULAbs.new(ULVar.new(0))) end
def eraseTypes; ULAbs.new(ULAbs.new(ULVar.new(0))) end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STSuc(t)</code>, the <code>Suc</code> part is default, and <code>ULApp</code> is used to combine it with t in untyped lambda form.</li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def eraseTypes
    return ULApp.new(ULAbs.new(ULAbs.new(ULAbs.new(ULApp.new(
      ULVar.new(1),ULApp.new(ULApp.new(ULVar.new(2),ULVar.new(1)),ULVar.new(0)))))),t.eraseTypes) 
end
</pre>
</div>

<ul class="org-ul">
<li>For <code>STApp</code> and <code>STAbs</code>, they are translated using recursion</li>
</ul>
<div class="org-src-container">
<pre class="src src-ruby">def eraseTypes; ULApp.new(t1.eraseTypes,t2.eraseTypes) end
def eraseTypes; ULAbs.new(t2.eraseTypes) end
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cynthia Liu</p>
<p class="date">Created: 2020-11-26 Thu 21:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
